# design-pattern

## 1. 생성 패턴(Creational Pattern)

### [Factory Method(팩터리 메서드)](src/creational/FactoryMethod.java)

> 상위 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴을 의미한다. 하위 클래스가 어떤 객체를 생성할지 선택한다.   
> (이름으로 인해 객체를 생성하는 메서드를 Factory Method라 오해하는 개발자가 많이 있다.)

### [Abstract Factory(추상 팩터리)](src/creational/AbstractFactory.java)

> 구체적인 클래스에 의존하지 않고 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다.
> 이를 통해 연관된 서브 클래스를 묶어 한번에 교체가 가능하다. 이렇게 일관성은 늘어나지만, 반대로 확장성은 매우 떨어진다.
> 메서드 하나를 추가하기 위해서는 이미 만들어진 클래스에서 전부 구현해야 한다. (default keyword가 존재하지만, 해당 기능을 각 클래스에서 구현해야 하는것은 변하지 않는다.)
 
### [Builder(빌더)](src/creational/Builder.java)

> 복합 객체의 생성 과정과 표현 과정을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 얻어 낼 수 있게 하는 패턴이다. 
> 생성자가 길어지면 타입과 순서 관리가 힘들어지고, 오류 발생 확률이 높아진다. 이러한 문제를 해결하기 위하여 나온 패턴이다.  
> (디렉터를 통해 클라이언트 코드를 더 짧게 유지할 수 있다.)

### [Prototype(프로토타입)](src/creational/Prototype.java)

> 객체를 생성하는데 비용이 많이 들고, 비슷한 객체가 이미 존재할 때 사용하는 패턴이다.
> 생성할 객체들이 프로토타입인 인스턴스를 통해 결정되도록 하고 인스턴스는 새 객체를 만들기 위해 자기 자신을 복제한다.

### [Singleton(싱글톤)](src/creational/Singleton.java)

> 객체를 단 하나만 생성하여 어디서든 같은 객체를 사용한다. 객체가 단 하나이기에 메모리 관점에서 유리하다.  
> 단, 싱글톤으로 생성한 객체는 stateless를 유지해야 한다. 여러 쓰레드에서 접근 시 동시성 문제가 발생할 수 있다.

## 2. 구조 패턴(Structural Pattern)

### [Adapter(어댑터)](src/structural/Adapter.java)

> 클래스들의 호환성을 맞춰주는 패턴이다. 기존의 클래스를 사용하고 싶지만 인터페이스가 일치하지 않을 경우에도 동작하도록 만들어주는 패턴이다.
> 향후 클래스가 변경되더라도, 어댑터에 의해 캡슐화 되어있기 때문에 클라이언트는 바뀐 내용을 알 필요가 없다.
 
### [Bridge(브리지)](src/structural/Bridge.java)

> 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴이다. 기능과 구현을 별도 클래스에서 구현한다.

### [Composite(컴퍼지트)](src/structural/Composite.java)
> 객체들간의 관계를 트리 구조로 구성하여 부분과 전체 계층을 표현하는 패턴이다. 클라이언트가 단일 객체와 복합 객체를 모두 동일하게 다룰 수 있다.